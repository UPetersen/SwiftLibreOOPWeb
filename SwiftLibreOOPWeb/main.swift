//
//  main.swift
//  SwitftOOPWeb
//
//  Created by Bjørn Inge Berg on 08.04.2018.
//  Copyright © 2018 Bjørn Inge Berg. All rights reserved.
//

import Foundation

// Example Libre patch contents
// This would typically by a full readout
// of the sensor from a blureader,blucon, miaomiao or some other nfc to bluetooth bridge
var patch : [UInt8] = [0x3a, 0xcf, 0x10, 0x16, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x4f, 0x11, 0x08, 0x10, 0xad, 0x02, 0xc8, 0xd4,
0x5b, 0x00, 0xaa, 0x02, 0xc8, 0xb4, 0x1b, 0x80,
0xa9, 0x02, 0xc8, 0x9c, 0x5b, 0x00, 0xa9, 0x02,
0xc8, 0x8c, 0x1b, 0x80, 0xb0, 0x02, 0xc8, 0x30,
0x5c, 0x80, 0xb0, 0x02, 0x88, 0xe6, 0x9c, 0x80,
0xb8, 0x02, 0xc8, 0x3c, 0x9d, 0x80, 0xb8, 0x02,
0xc8, 0x60, 0x9d, 0x80, 0xa1, 0x02, 0xc8, 0xdc,
0x9e, 0x80, 0xab, 0x02, 0xc8, 0x14, 0x9e, 0x80,
0xa9, 0x02, 0xc8, 0xc0, 0x9d, 0x80, 0xab, 0x02,
0xc8, 0x78, 0x9d, 0x80, 0xaa, 0x02, 0xc8, 0x40,
0x9d, 0x80, 0xa8, 0x02, 0xc8, 0x08, 0x9d, 0x80,
0xa8, 0x02, 0xc8, 0x2c, 0x5c, 0x80, 0xad, 0x02,
0xc8, 0xf8, 0x5b, 0x00, 0x29, 0x06, 0xc8, 0xf4,
0x9b, 0x80, 0xc9, 0x05, 0xc8, 0x8c, 0xde, 0x80,
0xc3, 0x05, 0xc8, 0x28, 0x9e, 0x80, 0x2c, 0x06,
0xc8, 0xd0, 0x9e, 0x80, 0x7b, 0x06, 0x88, 0xa6,
0x9e, 0x80, 0xf9, 0x05, 0xc8, 0xb0, 0x9e, 0x80,
0x99, 0x05, 0xc8, 0xf0, 0x9e, 0x80, 0x2e, 0x05,
0xc8, 0x00, 0x9f, 0x80, 0x81, 0x04, 0xc8, 0x48,
0xa0, 0x80, 0x5d, 0x04, 0xc8, 0x38, 0x9d, 0x80,
0x12, 0x04, 0xc8, 0x10, 0x9e, 0x80, 0xcf, 0x03,
0xc8, 0x4c, 0x9e, 0x80, 0x6f, 0x03, 0xc8, 0xb8,
0x9e, 0x80, 0x19, 0x03, 0xc8, 0x40, 0x9f, 0x80,
0xc5, 0x02, 0xc8, 0xf4, 0x9e, 0x80, 0xaa, 0x02,
0xc8, 0xf8, 0x5b, 0x00, 0xa2, 0x04, 0xc8, 0x38,
0x9a, 0x00, 0xd1, 0x04, 0xc8, 0x28, 0x9b, 0x80,
0xe4, 0x04, 0xc8, 0xe0, 0x1a, 0x80, 0x8f, 0x04,
0xc8, 0x20, 0x9b, 0x80, 0x22, 0x06, 0xc8, 0x50,
0x5b, 0x80, 0xbc, 0x06, 0xc8, 0x54, 0x9c, 0x80,
0x7f, 0x05, 0xc8, 0x24, 0x5c, 0x80, 0xc9, 0x05,
0xc8, 0x38, 0x5c, 0x80, 0x38, 0x05, 0xc8, 0xf4,
0x1a, 0x80, 0x37, 0x07, 0xc8, 0x84, 0x5b, 0x80,
0xfb, 0x08, 0xc8, 0x4c, 0x9c, 0x80, 0xfb, 0x09,
0xc8, 0x7c, 0x9b, 0x80, 0x77, 0x0a, 0xc8, 0xe4,
0x5a, 0x80, 0xdf, 0x09, 0xc8, 0x88, 0x9f, 0x80,
0x6d, 0x08, 0xc8, 0x2c, 0x9f, 0x80, 0xc3, 0x06,
0xc8, 0xb0, 0x9d, 0x80, 0xd9, 0x11, 0x00, 0x00,
0x72, 0xc2, 0x00, 0x08, 0x82, 0x05, 0x09, 0x51,
0x14, 0x07, 0x96, 0x80, 0x5a, 0x00, 0xed, 0xa6,
0x0e, 0x6e, 0x1a, 0xc8, 0x04, 0xdd, 0x58, 0x6d];

//note that the accesstoken will be given to you by the libreoopweb admin
let accesstoken = "someName-FollowedByRandomNumberGivenToYouByLibreoopwebAdmin"

let remote = RemoteBG(accesstoken: accesstoken)
let sema = DispatchSemaphore( value: 0 )

remote.uploadReading(reading: patch) { (resp) in
    if let uuid = resp.result?.uuid{
        print("uuid received: " + uuid)

        // The completion handler will be called once the result is available, or when a timeout is received
        // The timeout can be calculated as approx (intervalSeconds * maxTries) seconds
        // In case of timeout, the success parameter will be false, errormessage will have contents
        // and the response will be "N/A"
        // In case of success, response will be a string containing the result of the Algorithm
        remote.getStatusIntervalled(uuid: uuid, { (success, errormessage, response) in
            
            NSLog("GetStatusIntervalled returned with success?: \(success), error: \(errormessage), response: \(response))")
        })
        
    }
    
    
}



//This semaphore wait is neccessary when running as a mac os cli program. Consider removing this in a GUI app
//it kinda works like python's input() or raw_input() in a cli program, except it doesn't accept input, ofcourse..
sema.wait()





